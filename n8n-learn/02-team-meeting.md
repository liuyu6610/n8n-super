# 周二组内宣讲：为什么引入 n8n，以及“钉钉审批→自动部署”首个改造方案

## 1. 会议目标（你要讲清楚的三件事）

- **[为什么要上]** 现在流程/脚本分散，人工串联成本高且不可追溯，引入 n8n 目的是把“人脑流程”产品化。
- **[能带来什么]** 把审批、发布、告警事件、脚本执行统一编排，形成可审计的自动化流水线。
- **[先改什么]** 第一优先级：把“钉钉审批→GitLab 合并→Jenkins 构建镜像→ArgoCD 部署→验证→回填”做成一个端到端 n8n 工作流。

## 2. 现状流程（人工串联的典型问题）

当前流程（你描述的现实版）：

1. 开发在钉钉发起审批（版本更新/发布申请）
2. 审批到 SRE 之后：
   - 人工在内网 GitLab 合并 MR
   - 人工进入 Jenkins 点构建镜像/等待成功
   - 人工进 ArgoCD 做部署/等待健康
   - 人工验证无误
   - 回钉钉填“已办理”

问题：

- **执行依赖人**：中间任一环节忘点/点错就出事故
- **效率低**：等待构建/等待部署期间人被占用
- **可追溯性弱**：事后复盘很难快速定位“这次发布到底做了啥”
- **一致性差**：不同人执行细节不同，风险不可控

## 3. 引入 n8n 对 SRE 的价值（建议用这 5 条做主线）

- **[把流程变成资产]** 工作流是可视化拓扑，天然就是“流程文档 + 可执行定义”。
- **[每次执行都有证据链]** n8n 会记录每次执行输入/输出/状态/耗时/错误，便于审计与复盘。
- **[串联系统能力强]** HTTP/Webhook/CI/CD/IM/DB/脚本都能接；对内网系统很友好。
- **[可以规模化]** Queue 模式（Redis + Worker）能把执行器水平扩容，不靠人堆。
- **[风险可控]** 可以在关键节点插入校验/等待/人工确认；失败时自动通知与回滚。

## 4. 落地边界（建议提前说明，避免误解）

- **n8n 负责“编排 + 审计 + 通知 + 回写”**。
- **高风险动作不要直接在 n8n 容器里随意 `Execute Command`**：
  - 生产建议通过“受控执行器”（Jenkins/AWX/自研 Agent）执行变更
  - n8n 作为控制面（control plane），把权限收敛、审计拉满

你们的 `n8n-super` 镜像已经为 SRE 场景做了增强（见 `./03-n8n-super-ops.md`）：

- 预装 `argocd` CLI
- 预装常用社区节点：钉钉、GitLab、Jenkins、K8s、Helm、ntfy、Browser、PythonFunction

## 5. 首个急需改造：钉钉审批 → 自动部署（端到端工作流）

### 5.1 输入契约（审批单必须结构化，否则自动化无法稳定）

建议在钉钉审批表单里强制填写这些字段（最小集合）：

- **业务/系统名**：`service`
- **GitLab 项目**：`gitlabProjectId` 或 `repoUrl`
- **Merge Request**：`mrIid`（或 `mrUrl`）
- **目标环境**：`env`（dev/staging/prod）
- **ArgoCD App**：`argocdApp`
- **发布备注**：`note`

建议增加（用于风控/追溯）：

- **发布窗口**：`changeWindow`
- **回滚策略**：`rollbackPolicy`（auto/manual）
- **验证 URL**：`healthUrl`（或多 URL 列表）

### 5.2 触发方式（两种落地路径）

- **方式 A（可选，准实时）**：在公网/DMZ 部署轻量中转服务（或企业 API 网关），接收钉钉回调后写入“内网可拉取的队列/DB”，n8n 从内网主动拉取并触发执行。
- **方式 B（推荐，现阶段）**：n8n 定时轮询钉钉审批实例/待办任务（Schedule Trigger），发现“已通过未处理”的单子再执行。

> 当前你们无法让钉钉回调直接打到内网 n8n，所以先落地方式 B；后续如果需要更强实时性，再评估方式 A。

### 5.3 工作流拓扑（节点级别的实现蓝图）

下面是建议的工作流节点顺序（按你们现有 `n8n-super` 节点能力设计）：

1. **Schedule Trigger + DingTalk/HTTP Request（轮询触发）**
   - 定时拉取“已通过且待处理”的审批实例/待办任务（输出审批单字段）
2. **Set / Code (JS)**
   - 生成 `runId`（例如 `timestamp + mrIid`）
   - 标准化字段：`service/env/mrIid/argocdApp/healthUrl`
3. **If（幂等校验）**
   - 查询 GitLab MR 状态：是否已合并？是否已关闭？
4. **GitLab（Get MR）**
   - 拉取 MR 详情（是否可合并、是否冲突、是否满足策略）
5. **GitLab（Merge MR）**
   - 自动合并
   - 合并失败：走失败分支（通知 + 回填）
6. **Jenkins（Trigger Job / Build with Parameters）**
   - 参数建议：`service/env/commitSha/runId`
7. **Loop: Wait + Jenkins（Get Build Status）**
   - 周期查询构建状态
   - 超时失败：走失败分支
8. **Execute Command（argocd app sync / wait）**

    - `argocd app sync <app>`
    - `argocd app wait <app> --health --timeout <sec>`

9. **HTTP Request（健康检查）**

    - 调用 `healthUrl`（或冒烟接口）

10. **DingTalk（通知/回写）**

    - 成功：回填“已办理”，附带：commit、镜像 tag、Argo revision、执行链接
    - 失败：回填失败原因，附带执行链接与排障建议

> 说明：你们的 `n8n-super` 镜像已经内置 `argocd` CLI，非常适合在第 8 步直接调用。

### 5.4 凭据与权限（SRE 落地必须讲清楚）

建议使用 4 组“专用账号/Token”，权限最小化：

- **GitLab Bot Token**
  - 仅允许对特定项目 MR 进行合并、读 MR 信息
- **Jenkins API Token**
  - 仅允许触发指定 Job、读取构建状态
- **ArgoCD Token**
  - 仅允许对指定 App 执行 `sync/wait`（避免拥有全局管理员）
- **钉钉机器人 / API 权限**
  - 仅允许向对应群/审批实例回写

凭据存放原则：

- 不把 token 写进 workflow JSON
- 使用 n8n Credentials 管理
- 如具备企业能力，可进一步接外部 Secrets（Vault/ASM 等）

### 5.5 失败处理与回滚（建议你在会上重点强调“可控”）

- **合并失败**：直接回填失败原因（冲突/权限/策略不满足）
- **构建失败**：回填失败 + 给出 Jenkins 构建链接/控制台日志摘要
- **部署失败**：
  - 可选：自动执行 `argocd app rollback`（前提：你们团队定义了回滚策略）
  - 回填失败原因 + 提示人工介入点
- **健康检查失败**：
  - 默认走失败分支
  - 可配置：重试 N 次仍失败→回滚

### 5.6 效率提升点（你可以用“前后对比表”讲）

|步骤|当前（人工）|改造后（n8n）|
|---|---|---|
|合并 MR|人工确认/合并|自动（带校验/幂等）|
|触发构建|人工点击|自动触发 + 自动等待|
|部署|人工点 ArgoCD|自动 sync + 自动 wait|
|验证|人工盯着|自动 health check + 可插入更多检查|
|回填钉钉|人工填写|自动回填（成功/失败）|

最终结果：

- 人从“执行者”变成“审核者/策略维护者”
- 流程耗时不一定大幅变短，但 **人的占用时间会显著下降**
- 每次发布自动生成执行记录，复盘成本降低

## 6. 把其它工作也用同一套路串起来（思路即可）

### 6.1 告警事件闭环

- N9E/Alertmanager → Webhook → 规则化（去重/丰富/路由） → 通知/工单 → 自动化处置（受控） → 回写状态

### 6.2 机器初始化/装机脚本

- 发起审批（变更窗口/目标机器/脚本版本）→ n8n 编排 → 调 AWX/Jenkins/Agent 执行 → 汇总结果 → 通知/回写

### 6.3 日常运维自动化

- 定时巡检、容量检查、证书到期检查、账号过期检查
- 统一在 n8n 做编排与通知，把“脚本散落”变成“流程资产化”

## 7. 推荐落地节奏（最短路径）

- **第 1 周**：搭建 n8n（建议直接用 `n8n-super`，优先 Queue 形态），把钉钉→自动部署跑通
- **第 2~3 周**：把发布流程做成“标准模板”（含校验/回滚/通知/审计字段），并固化到 Git
- **后续**：把告警事件闭环、装机初始化逐步迁移进来，形成 SRE 自动化体系

> 下一份文档（文件3/4）会分别讲清楚：
>
>- `n8n-super` 的镜像与运维改造点（为何这样设计、怎么扩展、怎么控风险）
>- Workflow-as-Code：怎么把工作流像代码一样版本化、评审、发布、回滚、审计
